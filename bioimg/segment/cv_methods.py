#!/usr/bin/env python3
"""
Classical computer vision segmentation algorithms
such as watershed or spot detection
"""

import scipy.ndimage as nd
import numpy as np
import pandas as pd
from skimage.morphology import disk, binary_closing, binary_erosion
from skimage import feature
from skimage import morphology
from skimage import segmentation
from skimage.feature import shape_index, blob_log
from skimage.filters import gaussian
from skimage.measure import label
from skimage.measure import regionprops
import skimage

from ..base.process import threshold_img


def get_feattable(feats, keys):
    '''Get region property summary as DataFrame
       ----------------------------------------
       Subsets regionprops object to selected keys and
       returns a DataFrame

       Parameters
       ----------
       feats : RegionProperties object
       keys : list of strings

       Returns
       -------
       DataFrame : pd.DataFrame of selected features

    '''
    return pd.DataFrame({key: [f[key] for f in feats] for key in keys})


def get_bounds(feat_df, key, bounds):
    '''Find regions within the RegionProperties bounded range
       ------------------------------------------------------
       Returns a boolean array for image regions whose properties
       are within the specified bounds

       Parameters
       ----------
       feat_df : DataFrame
           Region properties of the image as DataFrame
       key : key of a dict
       bounds : tuple
           Tuple of length 2 with lower_bound = bounds[0] and
           upper_bound = bounds[1]

       Returns
       -------
       array : bool np.array, with True if region is within the bounds
    '''
    series = np.logical_and(feat_df[key] > bounds[0], feat_df[key] < bounds[1])
    return series.values


def filter_segm(img, labels, bounds):
    '''Subset labelled pixel map (segmentation)
       ----------------------------------------
       The function allows to subset the segmentation
       by providing lower and upper bounds of various
       region properties


       Parameters
       ----------
       img : (nrow, ncol) array
           Intensity image
       labels : (nrow, ncol) array
           Labelled image (generated by segmentation)
       bounds : dict
           Dictionary with keys naming features (regionprops)
            and values providing lower and upper bounds


       Returns
       -------
       segm_out : (nrow, ncol) array
           Filtered labelled array
        '''
    feats = regionprops(label_image=labels, intensity_image=img)
    feat_df = get_feattable(feats, keys=bounds.keys())
    # this tuple accumulates bounded bool arrays
    tuple_and = tuple((get_bounds(feat_df, key=k, bounds=b))
                      for k, b in bounds.items())
    # chained np.logical_and ((arr_1, arr_2, arr_3,...))
    feat_subset = np.logical_and.reduce(tuple_and)
    label_subset = np.where(feat_subset)[0] + 1
    # only labels that are bounded by bounds['key']
    segm_out = labels*np.isin(labels, label_subset)

    return segm_out


def find_markers(imgstack, perc=95, mdist=3):
    markers = np.zeros_like(imgstack)

    for i in range(imgstack.shape[0]):
        th = np.max((np.percentile(imgstack[i, :, :], perc),
                     np.percentile(imgstack, perc)))
        markers[i, :, :] = feature.peak_local_max(imgstack[i, :, :],
                                                  threshold_abs=th,
                                                  indices=False,
                                                  min_distance=mdist)
    return markers


def intersect_nd(arrA, arrB):
    return not set(map(tuple, arrA)).isdisjoint(map(tuple, arrB))
